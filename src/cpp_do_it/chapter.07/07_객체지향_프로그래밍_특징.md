# 객체지향 프로그래밍 특징
---------------------------------------
# 07-1 추상화와 캡슐화
- 추상화를 이해하고 클래스 정의하기
- 캡슐화를 통해 재사용성이 높으면서 신뢰성이 보장된 클래스 생성하기

## 추상화란 무엇일까?
- 복잡한 자료, 모듈, 시스템 등으로부터 핵심 개념이나 기능을 간추리는 것.
- **추상화**(abstraction): 공톡된 특징은 추출하고 불필요한 부분은 제거하여 코드를 간결하고 이해하기 쉽게 만드는 작업

## 캡슐화란 무엇일까?
- **캡슐화**(encapsulation): 변수와 함수를 클래스로 감싸서 외부에서는 개별적으로 접근할 수 없도록 묶어서 관리하는 것.
- 즉 클래스 밖에서 내부의 멤버에 접근할 수 없도록 정보를 **은닉화**(hiding)함.

- bank.cpp 참고
- class_name 변수_이름 --> 인스턴스 생성하는 코드
- **인스턴스**는 클래스가 메모리에 할당되어 생성된 변수, 메모리에 실체화된 객체의 형태

# 07-2 상속성과 다형성
- 상속성 이해와 자식 클래스 만들기
- 다형성 이해와 자식 클래스에 다형성 적용하기

## 상속성이란 무엇일까?
- 상속: 클래스를 만들 때, 다른 클래스의 멤버를 물려받는 것.
- 상속성: 다양한 특성으로 추상화하고 캡슐화한 클래스를 확장하고 변형하는 방법.
- 자식 클래스 = 파생클래스 = 하위 클래스: 상속 받은 클래스
- 부모 클래스 = 기본 클래스 = 슈퍼 클래스: 상속해 주는 클래스
- **상속의 장점**: 공통된 특징은 부모 클래스의 멤버를 사용하고 자식 클래스에서는 고유한 특징만 별도로 정의해서 사용할 수 있음.
- 부모 클래스는 각 멤버를 일반화하여 범용으로 설계하고, 자식 클래스에서는 개별적이거나 특수한 멤버를 가지도록 설계

### 부모 클래스를 대신할 수 있는 자식 클래스
- **부모 클래스를 자식 클래스로 치환**할 수 있어야 함. 
- 중요한 상속의 특징임. 
- 부모가 외부로 노출한 함수의 시그니처*를 그대로 상속해야함 
*시그니처: 함수의 이름, 매개변수 구성, 반환 형식을 아우르는 말
- 치환한다는 것은 단순히 형식만 같은 것이 아니라 부모 클래스의 모든 제약 사항과 동작 방식을 그대로 유지한다는 뜻. --> 이를 **리스코프 치환 원칙**이라고 함.

## 다형성이란 무엇일까? 
- 다형성(polymorphism)은 상속 받은 클래스들이 부모와 다른 다양한 특성을 가지는 것.

## 함수 재정의하기 - 오버라이딩
- 다형성을 구현하려면 오버라이딩을 이용해야함.
- **오버라이딩**: 시그니처는 그대로 유지하면서 부모 클래스에 정의된 함수를 자식 클래스에서 재정의하는 것

# 객체 지향 프로그래밍 특징 정리

## 추상화
- 여러 개의 복잡한 자료, 모듈, 시스템 등으로부터 공통된 핵심 개념이나 기능을 간추림
- 공통된 특징을 추출하여 클래스를 간결하게 만들어 이해하기 쉽게 만듦.

## 캡슐화 
- 클래스의 구체적인 동작을 외부로 노출하지 않도록 감추는 것. 
- 멤버 변수와 멤버 함수를 낱개로 외부에서 사용할 수 있게 하는 것이 아니라 묶어서 관리
- 복잡도는 낮아지고 재사용성은 증가함

## 상속성 
- 부모 클래스의 데이터와 기능을 자식 클래스가 물려받아 확장함.

## 다형성
- 하나의 클래스가 다양한 형태의 속성과 기능을 할 수 있음을 나타냄.

# 07-3 생성자와 소멸자
- 생성자와 소멸자의 개념 이해

## 생성자 
- 객체가 생성될 때마다 객체 내부나 외부에 초기화해야할 속성들이 있음.
- 초기화하는 작업은 별도의 함수를 만들어 객체 생성 후에 호출하면 됨.
- 프로그램에는 많은 객체가 사용되는데 객체를 생성할 때마다 초기화 함수를 별도로 호출해야 한다면 개발자가 놓칠 수 있음.
- --> 이때 **생성자**를 사용해야함.
- **생성자**(constructor)는 객체가 생성된 직후에 자동으로 호출되는 함수
- 이러한 특징을 이용해 생성자에서 속성을 초기화하는 등 객체를 사용할 준비를 함. 
```cpp
// 생성자 선언 --> 클래스_이름()
class character {
    public:
        character() {
            // 멤버 변수를 초기화하는 코드를 작성
        };
};
```
## 멤버 변수 초기화
- 객체가 생성될 때, 초기화가 필요한 멤버 변수는 생성자를 이용해야함.
- 특히 **레퍼런스 멤버** 변수와 **상수 멤버** 변수는 생성자에서 반드시 초기화 해야함.

### 일반 멤버 변수 초기화
- 일반 멤버 변수는 생성자에서 일반적인 **대입 연산(=)**으로 초기화하는 방법과 생성자 선언 뒤쪽에 **초기화 목록**을 이용하는 방법이 있음.
- 초기화 목록을 이용할 때는 **직접 초기화 구문**을 사용함. 
```cpp
monster_b() : monster_type("일반") { // 초기화 목록 이용(직접 초기화)
    difficult_level = 10;           // 대입 연산 이용(복사 초기화)
};
```
- 대입 연산은 데이터가 복사되므로 복사 초기화라고 함. 성능에 미세한 차이가 존재함.

### 정적 멤버 변수 초기화
- 정적 멤버 변수를 static으로 선언하면 해당 클래스로 생성하는 모든 객체에서 참조할 수 있음
- 따라서 클래스에 선언한 정적 변수는 **전역 범위에서 초기화**해야 함.
```cpp
class_name::정적_멤버_변수 = 값; // 클래스 범위 밖의 전역에서 초기화
```
--> 가독성을 위해서 클래스가 선언된 소스 파일의 최상단이나 클래스 선언부 밑에 작성하는 것이 좋음.

## 문법 요약
```cpp
class monster_b : public monster, character {
public:
    monster_b(player &attack_target)    
        : monster_type("일반"),          // 1. 직접 초기화   
        location{0,0},                  // 2. 유니폼 초기화
        unique_id(++total_count),       // 3. 상수 변수 초기화
        target(attack_target) {         // 4. 레퍼런스 변수 초기화
            difficult_level = 10;       // 5. 복사 초기화
            quiz = new char[1024];      // 6. 동적 메모리 할당
        };
private:
    string monster_type;                // 7. 멤버 변수 목록
    int location[2];
    static int total count;
    const int unique_id;
    player &target;
    int difficult_level;
    char *quiz;
};

int monster_b::total_count = 0;         // 8. 정적 변수 초기화
```

## 복사 생성자
- 복사 생성자란 객체가 복사될 때, 자동으로 호출되는 함수를 의미함.

## 소멸자
- 소멸자는 객체가 소멸할 때 필요한 메모리 해제나 외부 환경을 객체 생성 이전 상태로 변경하는 일을 진행.
- 기본 소멸자: ~클래스_이름()

# 07-4 자신을 가리키는 this 포인터
- this는 객체 내부에서 객체 자신을 가리키는 키워드

## 객체가 메모리에 할당되는 구조
- this 포인터는 멤버 함수 내에서 자동으로 생성되어 해당 함수가 속한 객체의 주소를 가리킴.
- 멤허 함수를 호출하는 코드에서는 객체의 주소를 **자동으로** 첫번째 인자로 전달하고, 이에 맞춰 멤버 함수에서는 this 포인터로 주소를 전달 받아서 멤버 변수에 접근할 때 사용함. 

## 지역 변수와 구별할 때
- 매개 변수 이름이 멤버 변수 이름과 같아서 헷갈릴 때, 멤버 변수를 this 포인터로 표현할 수 있음.
- ex) this->safe 와 safe는 각각 멤버 변수와 매개변수를 가리킴.
- **bank.cpp** 참고

## 멤버 함수 체이닝을 구현할 때
- 함수 체이닝이란 여러 함수를 연이어 호출하는 방식을 말함.
- 이는 멤버 함수가 객체를 반환하고 해당 객체에서 다시 멤버 함수를 호출하는 방식
- 이러한 스타일은 코드를 간결하게 만들고 호출 순서를 직관적으로 표현할 수 있음.
- function_chanining.cpp 참고

# 07-5 함수와 연산자 오버로딩

## 함수 오버로딩

- 함수 오버라이딩: 어떤 규칙이나 권력에 앞서거나 무시한다는 뜻. 
- 부모 클래스 오버라이딩: 부모의 정의를 무시하거나 그의 앞서 자식 클래스에 정의된 함수를 우선시
- 함수 오버로딩: 이미 정의된 함수와 같은 이름을 사용하지만 매개변수 구성을 변경해 가면서 새로운 정의를 계속 쌓는 의미. 

오버로딩이 필요한 상황 예

<일반적 상황>
1. 몬스터에 이동 기능을 구현한다고 생각. 
2. 함수 이름과 매개변수 정의 --> void move(int x, int y)
3. 개발하다 보니 특정 위치를 거쳐서 가야한느 요구 사항이 생김 
4. 새로운 함수를 void move_follow_path(int x[], int y[], int spot_count) 처럼 생성
--> 이런식으로 함수가 늘면 이름도 복잡해지고 코드를 이해하기가 어려워짐. 

<오버로딩 사용>
1. 위와 동일한 상황
2. 이름 동일, 매개변수 구성이 다른 함수 정의 void move(int x[], int y[], int spot_count)
3. 오버로딩을 통해서, 함수 이름이 같고 매개변수 구성만 다르니 이동에 관련된 다른 옵션이 있다고 이해. 
4. 또한 본문이나 호출하는 코드를 수정하지 않고 기능을 바꿔야할 때 사용하기도 함.
--> funtion_overload.cpp 참고

## 연산자 오버로딩

- 연산자 오버로딩은 함수끼리의 연산을 하는 것임.
- 같은 이름으로 함수 정의를 추가하는 오버로딩을 이용해서 더하기 연산자 함수를 만들어아 함.
- 예시 코드에서 몬스터 C끼리 서로 합체하면 레벨이 한 단계 상승하는 함수를 만든다고 생각. 
- --> 단순히 + 연산자로 합칠 수 있다면 좋지만 불가능.

<연산자 오버로딩>
- 반환_형식 operator연산자_기호(매개변수)
- operator_overload_monster.cpp 참고

# 07-6 접근 지정자와 프렌드
- 접근 지정자 public, private, protected 복습
- 상속 관계에서 접근 지정자의 접근 권한 변경 이해
- 외부에서 protected 멤버에 접근할 수 있는 friend 키워드 학습

## 상속에 따른 접근 지정자의 변화

접근 지정자
### private :
- 클래스 내의 멤버 함수에서만 접근 가능
- 상속 받은 클래스에서 접근 불가능
- 우선순위 높음

### public : 
- 다른 클래스 어디서든 접근 가능
- 상속 받은 클래스에서 접근 가능
- 우선순위 낮음

### protected : 
- 클래스 내의 멤버함수에서 접근 가능
- 상속받은 클래스에서도 접근 가능 
- 우선순위 중간

--> 상속 접근 지정자에 영향을 받아서 자식 클래스는 부모 클래스에 대한 접근 권한이 변경됨

ex) 상속 접근 지정자가 protected라면 부모 클래스의 public 멤버는 모두 protected 멤버로 변경됨

## 멤버 변수 공개를 지양해야 하는 이유
- 자유로운 접근은 의도하지 않게 설정되어 오류의 원인이 되기도 함.
- member_variable_access.cpp 참고
- --> 멤버 변수는 될 수 있으면 private으로 선언하고 멤버 함수에서 접근하도록 구현

## 프렌드 클래스
- 때때로 private나 protected 멤버를 특정 클래스에서만 public 처럼 접근하고 싶을 수 있음.
- 해당 클래스를 friend로 등록하면 됨. --> 친한 친구끼리 비밀 공유와 동일

## 문법 요약
```cpp
class gs_engine : public ic_engine {
    public:
    gs_engine();
    ~gs_engine();
    private:
    void acceleration_output();
    // 프렌드 클래스 선언
    friend class automobile;
};
```
