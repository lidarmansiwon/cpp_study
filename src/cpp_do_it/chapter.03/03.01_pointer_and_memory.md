# 포인터와 메모리


C와 C++ 언어에서 가장 강력한 도구로는 대표적으로 포인터가 뽑힌다.
- 포인터를 이해하기 위해서는 데이터가 메모리에 저장되는 구조를 알아야한다. 
- 포인터는 데이터가 저장된 메모리 주소를 저장하는 변수이다. 

포인터 변수의 크기는 데이터 형식과는 관련이 없음. 모든 포인터 변수의 크기는 동일
- 포인터 변수를 선언할 때 데이터 형식을 지정하는 이유는 해당 포인터가 가리키는 데이터의 형식을 명시하기 위함.
- 다중 포인터도 가능!
## 포인터와 연산자
```bash
char char_value = 'A';          
char *char_pointer = &char_value; # &(주소 연산자: 피연산자의 주소를 불러옴)

cout << "char_pointer:" << *char_pointer << endl; # *(역참조 연산자)
```

## 배열과 포인터 

- 배열 선언 --> 자료형 배열_이름[크기] = {값1, 값2, 값3, ...., 값n}
- 원소 접근 --> 배열_이름[인덱스] # 항상 0부터 시작함. 가장 마지막 원소는 "배열_이름[n-1]

### 포인터 연산으로 배열의 원소에 접근하기
- 배열의 인덱스로 접근 and 포인터 연산으로 각 원소에 접근
--> &lotto[0] == lotto + 0과 동일함 --> 동일한 주소 반환
--> &배열_변수[인덱스] == 배열_변수 + 인덱스
--> ** 값을 불러오려면 *(역참조 연산자) 사용해야함!
--> ex) *(lotto + 7)

## 동적 메모리 할당 
- 동적 메모리를 할당하기 위해서는 new 키워드를 사용
- 자료형 *변수_이름 = new 자료형;
- 필요없는 시점에 delete 키워드로 반드시 해제해야함(직접).
- delete 변수_이름;

- 동적 할당 메모리 해제 이유: 함수의 매개변수나 지역변수처럼 대부분의 일반 변수는 Stack에 메모리가 할당되고 함수의 호출과 함께 할당되며 반환되면 자동으로 소멸함. 하지만 동적 할당 변수는 Heap이라는 메모리 영역에 존재하며 계속 유지됨. 메모리 영역도 훨씬 큼

**segmentation fault** 
- 프로그램이 허용되지 않은 메모리 영역에 접근을 시도하거나, 허용되지 않은 방법으로 메모리 영역제 접근을 시도할 때 발생
- **포인터를 역참조하기 전에 포인터가 유효한 메모리를 가리키는지** 확인이 필수
- 유효하지 않은 메모리를 가리키는 포인터를 역참조하려고 하면 위 오류나 런타임 오류가 발생할 수 있음

## 함수와 구조체
- function은 특정 작업을 수행하는 코드 집합
- 기본적인 구성
```
int(반환 형식) func(함수이름) (int _arg1, int _arg2) (매개변수)
{
    함수 몸체       
}
```

### 함수 선언의 4가지 필수 요소
1. 반환 형식: 함수가 반환할 값의 자료형. 반환할 값이 없을 때는 void로 표기
2. 함수 이름: 함수를 호출할 때 사용할 이름. 함수의 이름은 문자나 _(밑줄)로 시작하며 숫자X, 공백 X
3. 매개 변수: 함수가 호출될 때 전달받은 값을 저장하는 변수로, 함수 내부에서만 사용할 수 있는 지역 변수. 전달 받을 값이 없을 때는 비워두거나, void로 매개변수가 없음을 표기할 수 있음.
4. 함수 몸체: 함수의 기능을 정의하는 부분


### function.cpp 작성 중 size 관련 궁금증 답변
🔍 핵심 차이점
1. main 함수에서의 sizeof(score)
int score[5] = {90, 75, 80, 100, 65};    
score_size = sizeof(score) / sizeof(int);   
score는 이 시점에서는 정확히 크기가 정해진 배열이야. 즉, int[5]형이야.   

sizeof(score)는 배열 전체의 바이트 크기를 줘. int가 4바이트라면, 5 * 4 = 20바이트.

sizeof(int)는 당연히 4바이트.

따라서 score_size = 20 / 4 = 5.

2. average 함수에서의 sizeof(_array)
int average(int _array[], int _count)
{
    score_size = sizeof(_array) / sizeof(int);
    // ...
}
여기서 _array는 배열처럼 보이지만 실제로는 포인터야!

C++에서는 배열을 함수의 인자로 전달할 때 배열이 포인터로 decay(변형) 돼서 전달돼. 즉, _array는 사실상 int* _array로 해석돼.

sizeof(_array)는 포인터의 크기를 반환해. 일반적으로 8바이트 (64비트 시스템 기준).

sizeof(int)는 여전히 4바이트.

결과적으로 score_size = 8 / 4 = 2가 되는 것처럼 보일 수도 있어.

하지만 정확한 값은 시스템 아키텍처에 따라 다르고, 어쨌든 중요한 건 sizeof(_array)는 배열 전체 크기가 아니라 포인터 크기라는 점이야.

✅ 요약

위치	            sizeof                 결과	이유
main() 함수 내	    배열 전체 크기	        score는 int[5] 타입
average() 함수 내	포인터 크기	        _array는 int*로 해석됨 (배열 → 포인터 decay)

```bash
## 동일 표현
int average(int _array[], int _count)

int average(int* _array, int _count)

즉, _array는 score 배열의 첫 번째 요소의 주소를 가리키는 포인터.
함수 안에서 _array[i]라고 쓰는 건, 포인터 연산을 이용한 배열 접근.

## 동일 표현
sum += _array[i];

sum += *(_array + i);
```

